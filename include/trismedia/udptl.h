/*
 * Trismedia -- A telephony toolkit for Linux.
 *
 * UDPTL support for T.38
 * 
 * Copyright (C) 2005, Steve Underwood, partly based on RTP code which is
 * Copyright (C) 1999-2004, Digium, Inc.
 *
 * Steve Underwood <steveu@coppice.org>
 *
 * This program is free software, distributed under the terms of
 * the GNU General Public License
 *
 * A license has been granted to Digium (via disclaimer) for the use of
 * this code.
 */

/*! \file
 * \brief UDPTL support for T.38
 * \author Steve Underwood <steveu@coppice.org>
 * \ref udptl.c
 * \todo add doxygen documentation to this file!
 */


#ifndef _TRISMEDIA_UDPTL_H
#define _TRISMEDIA_UDPTL_H

#include "trismedia/network.h"
#include "trismedia/frame.h"
#include "trismedia/io.h"
#include "trismedia/sched.h"
#include "trismedia/channel.h"


enum tris_t38_ec_modes {
    UDPTL_ERROR_CORRECTION_NONE,
    UDPTL_ERROR_CORRECTION_FEC,
    UDPTL_ERROR_CORRECTION_REDUNDANCY
};

#if defined(__cplusplus) || defined(c_plusplus)
extern "C" {
#endif

struct tris_udptl_protocol {
	/*! \brief Get UDPTL struct, or NULL if unwilling to transfer */
	struct tris_udptl *(*get_udptl_info)(struct tris_channel *chan);
	/*! \brief Set UDPTL peer */
	int (* const set_udptl_peer)(struct tris_channel *chan, struct tris_udptl *peer);
	const char * const type;
	TRIS_RWLIST_ENTRY(tris_udptl_protocol) list;
};

struct tris_udptl;

typedef int (*tris_udptl_callback)(struct tris_udptl *udptl, struct tris_frame *f, void *data);

struct tris_udptl *tris_udptl_new(struct sched_context *sched, struct io_context *io, int callbackmode);

struct tris_udptl *tris_udptl_new_with_bindaddr(struct sched_context *sched, struct io_context *io, int callbackmode, struct in_addr in);

/*!
 * \brief Associates a character string 'tag' with a UDPTL session.
 * \param udptl The UDPTL session.
 * \param format printf-style format string used to construct the tag
 * 
 * This function formats a tag for the specified UDPTL
 * session, so that any log messages generated by the UDPTL stack
 * related to that session will include the tag and the reader of
 * the messages will be able to identify which endpoint caused them
 * to be generated.
 *
 * \retval none
 */
void __attribute__((format(printf, 2, 3))) tris_udptl_set_tag(struct tris_udptl *udptl, const char *format, ...);

void tris_udptl_set_peer(struct tris_udptl *udptl, const struct sockaddr_in *them);

void tris_udptl_get_peer(const struct tris_udptl *udptl, struct sockaddr_in *them);

void tris_udptl_get_us(const struct tris_udptl *udptl, struct sockaddr_in *us);

void tris_udptl_destroy(struct tris_udptl *udptl);

void tris_udptl_reset(struct tris_udptl *udptl);

void tris_udptl_set_callback(struct tris_udptl *udptl, tris_udptl_callback callback);

void tris_udptl_set_data(struct tris_udptl *udptl, void *data);

int tris_udptl_write(struct tris_udptl *udptl, struct tris_frame *f);

struct tris_frame *tris_udptl_read(struct tris_udptl *udptl);

int tris_udptl_fd(const struct tris_udptl *udptl);

int tris_udptl_setqos(struct tris_udptl *udptl, unsigned int tos, unsigned int cos);

void tris_udptl_set_m_type(struct tris_udptl *udptl, unsigned int pt);

void tris_udptl_set_udptlmap_type(struct tris_udptl *udptl, unsigned int pt,
				 char *mimeType, char *mimeSubtype);

enum tris_t38_ec_modes tris_udptl_get_error_correction_scheme(const struct tris_udptl *udptl);

void tris_udptl_set_error_correction_scheme(struct tris_udptl *udptl, enum tris_t38_ec_modes ec);

void tris_udptl_set_local_max_ifp(struct tris_udptl *udptl, unsigned int max_ifp);

/*! 
 * \brief retrieves local_max_datagram.
 * 
 * \retval positive value representing max datagram size.
 * \retval 0 if no value is present
 */
unsigned int tris_udptl_get_local_max_datagram(struct tris_udptl *udptl);

/*! 
 * \brief sets far max datagram size.  If max_datagram is = 0, the far max datagram
 *  size is set to a default value.
 */
void tris_udptl_set_far_max_datagram(struct tris_udptl *udptl, unsigned int max_datagram);

unsigned int tris_udptl_get_far_max_datagram(const struct tris_udptl *udptl);

/*! 
 * \brief retrieves far max ifp
 * 
 * \retval positive value representing max ifp size
 * \retval 0 if no value is present
 */
unsigned int tris_udptl_get_far_max_ifp(struct tris_udptl *udptl);

void tris_udptl_setnat(struct tris_udptl *udptl, int nat);

int tris_udptl_bridge(struct tris_channel *c0, struct tris_channel *c1, int flags,
		     struct tris_frame **fo, struct tris_channel **rc);

int tris_udptl_proto_register(struct tris_udptl_protocol *proto);

void tris_udptl_proto_unregister(struct tris_udptl_protocol *proto);

void tris_udptl_stop(struct tris_udptl *udptl);

void tris_udptl_init(void);

/*!
 * \version 1.6.1 return changed to int
 */
int tris_udptl_reload(void);

#if defined(__cplusplus) || defined(c_plusplus)
}
#endif

#endif
